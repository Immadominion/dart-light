import 'dart:typed_data';

import 'package:equatable/equatable.dart';

import 'bn254.dart';
import 'tree_info.dart';

/// Compressed proof data from the prover.
class CompressedProof extends Equatable {
  const CompressedProof({required this.a, required this.b, required this.c});

  /// First proof component (32 bytes).
  final List<int> a;

  /// Second proof component (64 bytes).
  final List<int> b;

  /// Third proof component (32 bytes).
  final List<int> c;

  /// Encode to Borsh bytes.
  /// Layout: [u8; 32] a, [u8; 64] b, [u8; 32] c
  Uint8List encode() {
    final buffer = BytesBuilder();
    buffer.add(Uint8List.fromList(a));
    buffer.add(Uint8List.fromList(b));
    buffer.add(Uint8List.fromList(c));
    return buffer.toBytes();
  }

  @override
  List<Object?> get props => [a, b, c];
}

/// Validity proof for state transitions.
///
/// A validity proof is a zero-knowledge proof that demonstrates:
/// 1. Input accounts exist in the state tree (inclusion proof)
/// 2. New addresses don't already exist (non-inclusion proof)
///
/// The proof is generated by the prover server and verified on-chain.
typedef ValidityProof = CompressedProof;

/// Validity proof with additional context.
class ValidityProofWithContext extends Equatable {
  const ValidityProofWithContext({
    required this.compressedProof,
    required this.roots,
    required this.rootIndices,
    required this.leafIndices,
    required this.leaves,
    required this.treeInfos,
    required this.proveByIndices,
  });

  /// The compressed validity proof (can be null for empty proofs).
  final ValidityProof? compressedProof;

  /// Merkle roots used in the proof.
  final List<BN254> roots;

  /// Indices of the roots in their respective trees.
  final List<int> rootIndices;

  /// Leaf indices for each input account.
  final List<int> leafIndices;

  /// Leaf values (account hashes).
  final List<BN254> leaves;

  /// Tree information for each leaf.
  final List<TreeInfo> treeInfos;

  /// Whether each account can be proven by index.
  final List<bool> proveByIndices;

  @override
  List<Object?> get props => [
    compressedProof,
    roots,
    rootIndices,
    leafIndices,
    leaves,
    treeInfos,
    proveByIndices,
  ];
}

/// Merkle context with proof for an account.
class MerkleContextWithMerkleProof extends Equatable {
  const MerkleContextWithMerkleProof({
    required this.hash,
    required this.treeInfo,
    required this.leafIndex,
    required this.merkleProof,
    required this.rootIndex,
    required this.root,
    this.proveByIndex = false,
  });

  /// Hash of the account.
  final BN254 hash;

  /// Tree containing the account.
  final TreeInfo treeInfo;

  /// Leaf index in the tree.
  final int leafIndex;

  /// Merkle proof path.
  final List<BN254> merkleProof;

  /// Root index (expires after ~n slots).
  final int rootIndex;

  /// Current root value.
  final BN254 root;

  /// Whether to prove by index.
  final bool proveByIndex;

  @override
  List<Object?> get props => [
    hash,
    treeInfo,
    leafIndex,
    merkleProof,
    rootIndex,
    root,
    proveByIndex,
  ];
}

/// New address proof result from the indexer.
class NewAddressProofResult extends Equatable {
  const NewAddressProofResult({
    required this.address,
    required this.nextIndex,
    required this.merkleTree,
    required this.proof,
    required this.rootSeq,
    required this.root,
    required this.lowerRangeAddress,
    required this.higherRangeAddress,
    required this.lowElementLeafIndex,
  });

  final BN254 address;
  final int nextIndex;
  final TreeInfo merkleTree;
  final List<BN254> proof;
  final int rootSeq;
  final BN254 root;
  final BN254 lowerRangeAddress;
  final BN254 higherRangeAddress;
  final int lowElementLeafIndex;

  @override
  List<Object?> get props => [
    address,
    nextIndex,
    merkleTree,
    proof,
    rootSeq,
    root,
    lowerRangeAddress,
    higherRangeAddress,
    lowElementLeafIndex,
  ];
}
